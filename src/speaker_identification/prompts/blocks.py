"""
Shared Prompt Blocks
====================

Reusable instruction blocks that are shared across multiple prompts.
These ensure consistency in how we instruct the LLM across all phases.

Each block is a string constant that can be included in prompt templates.
Blocks use standard Python string formatting - no f-string variables.

Usage:
    from src.speaker_identification.prompts.blocks import ADDRESSING_RULE

    prompt = f'''
    Your custom prompt here...

    {ADDRESSING_RULE}
    '''
"""

# =============================================================================
# CRITICAL RULES - These prevent common LLM mistakes
# =============================================================================

ADDRESSING_RULE = """
**CRITICAL - DO NOT MAKE THIS MISTAKE**:
If THIS SPEAKER says "Bruce?" or "Thanks, John" or "I agree with Peter" -
the speaker is NOT Bruce/John/Peter! They are ADDRESSING someone else.

WRONG: Speaker says "Bruce?" -> identify as Bruce (NO! They're calling to Bruce)
RIGHT: Speaker says "I'm Bruce" -> identify as Bruce (YES! Self-identification)
RIGHT: Another speaker says "Welcome Bruce" then THIS SPEAKER talks -> identify as Bruce (YES! Introduction)

Only match names that refer TO this speaker, not names this speaker uses to address others.
""".strip()

NO_HALLUCINATION_RULE = """
**CRITICAL: DO NOT HALLUCINATE OR GUESS**
- ONLY return information EXPLICITLY mentioned in the provided text
- If information is not present, return empty/unknown
- DO NOT use external knowledge about who might be involved
- DO NOT guess based on names, topics, or context clues alone
""".strip()


# =============================================================================
# TRANSCRIPTION GUIDANCE - Handle speech-to-text errors
# =============================================================================

PHONETIC_MATCHING = """
**IMPORTANT - TRANSCRIPTION ERRORS ARE COMMON:**
These transcripts are generated by speech-to-text systems that often misspell names phonetically.
Accept names that SOUND similar even if spelled very differently:
- "Anise Haydari" / "Anissa Dari" / "Annie Said Are" = "Anis Haydari" (phonetic variations)
- "John Smith" / "Jon Smyth" = same person
- "Dr. Brown" / "Doctor Brown" / "Doc Brown" = same person
- "David Plants" / "David Plotz" = same person (similar-sounding surnames)
- "Sean" / "Shawn" / "Shaun" = same name
If a name in the transcript is phonetically similar to an expected name, treat it as a MATCH.
The transcription system does NOT know the correct spelling - it guesses based on sound.
""".strip()

PHONETIC_MATCHING_SHORT = """
**IMPORTANT - TRANSCRIPTION ERRORS ARE COMMON:**
These are speech-to-text transcripts where names are spelled phonetically (by sound).
Accept similar-sounding names as matches (e.g., "Plotz"/"Plants", "Sean"/"Shawn").
If an expected name sounds similar to a name in the transcript, treat it as a MATCH.
""".strip()


# =============================================================================
# CONFIDENCE LEVELS - Standardized across all prompts
# =============================================================================

CONFIDENCE_LEVELS_STANDARD = """
Confidence levels:
- "certain": Explicit self-identification or direct introduction by name
- "very_likely": Being addressed by name, or strong contextual evidence
- "probably": Moderate supporting evidence
- "unlikely": No evidence or contradictory evidence
""".strip()

CONFIDENCE_LEVELS_HOST_VERIFICATION = """
CONFIDENCE LEVELS:
- "certain": Speaker explicitly self-identifies with a name matching or phonetically similar to the target
- "very_likely": Someone else addresses this speaker by a name matching or phonetically similar to the target
- "unlikely": No name evidence, OR speaker clearly identifies as a completely different person
""".strip()

CONFIDENCE_LEVELS_IDENTIFICATION = """
CONFIDENCE LEVELS:
- "certain": Self-identification ("I'm [Name]")
- "very_likely": Another speaker introduces or addresses them by name
- "probably": Context suggests a match but no direct name evidence
- "unlikely": No evidence or contradictory evidence
""".strip()

CONFIDENCE_LEVELS_GUEST_STRICT = """
CONFIDENCE LEVELS:
- "certain": Speaker explicitly self-identifies ("I'm [Name]", "My name is [Name]")
- "very_likely": Another speaker introduces them by name BEFORE they speak, OR directly addresses them by name
- "unlikely": No name evidence in transcript, or contradictory evidence

NOTE: Only return "certain" or "very_likely" if you have TRANSCRIPT EVIDENCE (a quote).
If you only have metadata/title evidence without transcript confirmation, return "unlikely".
""".strip()


# =============================================================================
# IDENTIFICATION GUIDANCE - What to look for
# =============================================================================

IDENTIFICATION_SOURCES = """
Look for:
1. SELF-IDENTIFICATION: "I'm [Name]", "This is [Name]", "My name is [Name]"
2. HOST INTRODUCTION: The host may introduce them ("Please welcome...", "Joining us is...")
3. BEING ADDRESSED: Another speaker addresses them by name before they speak
4. TITLE/DESCRIPTION: Names often appear in episode metadata
""".strip()

IDENTIFICATION_SOURCES_WITH_EXPECTED = """
Look for:
1. EXPECTED GUESTS: If metadata lists expected guests, check if transcript evidence matches any of them
2. SELF-IDENTIFICATION: "I'm [Name]", "This is [Name]", "My name is [Name]"
3. HOST INTRODUCTION: The host may introduce them
4. TITLE/DESCRIPTION: Guest names often appear in episode metadata
""".strip()


# =============================================================================
# ROLE CLASSIFICATION - Host vs Guest vs Co-host
# =============================================================================

ROLE_CLASSIFICATION = """
ROLE CLASSIFICATION:
- "host": Opens/closes shows, introduces guests, asks most questions, appears in many episodes
- "co_host": Regular contributor/panelist, appears frequently but doesn't lead
- "guest": One-time or occasional visitor, being interviewed
- "unknown": Cannot determine role from evidence
""".strip()

def get_role_classification_with_episodes(episode_count: int) -> str:
    """Get role classification text adjusted for episode count context."""
    return f"""
ROLE (based on {episode_count} episodes):
- {episode_count}+ episodes = "host" or "co_host" (NOT "guest")
- Opens/closes shows, introduces guests = "host"
- Regular panelist/contributor = "co_host"
- One-time appearance = "guest"
""".strip()


# =============================================================================
# JSON OUTPUT FORMATS - Standardized response structures
# =============================================================================

JSON_HOST_EXTRACTION = """
Return ONLY valid JSON (no markdown, no explanation):
{
  "hosts": [
    {
      "name": "Full Name",
      "confidence": "certain",
      "reasoning": "Why you identified this person"
    }
  ]
}

If no clear host, return {"hosts": []}.
""".strip()

JSON_EPISODE_SPEAKERS = """
Return ONLY valid JSON:
{
  "speakers": [
    {"name": "Full Name", "role": "host|guest", "confidence": "certain|very_likely", "reasoning": "Quote the exact text evidence"}
  ],
  "mentioned": [
    {"name": "Full Person Name", "reasoning": "Discussed in description"}
  ]
}

CONFIDENCE RULES (strict):
- "certain": Name appears EXPLICITLY in title or description (e.g., "with Dr. Smith", "John interviews...")
- "very_likely": Strong indirect evidence (e.g., title says "solo episode" for single-host show)
- If you cannot quote specific text mentioning the person, they should NOT be in speakers

Do NOT include hosts just because they are "known hosts" - they must be mentioned in THIS episode's metadata.
Return empty speakers array if no one is explicitly mentioned.
""".strip()

JSON_HOST_VERIFICATION = """
Return ONLY valid JSON. Fill in fields IN ORDER - evidence reasoning FIRST, then conclusions:
{
  "evidence": {
    "quote": "Exact quote containing the name evidence (or empty string if none)",
    "speaker_source": "this_speaker" | "previous_speaker" | "next_speaker" | "host" | "unknown",
    "type": "self_id" | "addressed_as" | "introduced_as" | "sign_off" | "third_person_ref" | "none",
    "interpretation": "Brief explanation of how quote identifies speaker"
  },
  "name": "Exact name if identifiable" (empty string if unknown),
  "confidence": "certain" | "very_likely" | "unlikely",
  "is_host": true/false
}

FILL IN ORDER: First find the quote, then determine who said it, then classify the evidence type,
then interpret what it means, THEN make your confidence and is_host decision based on that evidence.

EVIDENCE TYPES:
- "self_id": Speaker says "I'm X", "My name is X", "This is X speaking"
- "addressed_as": Another speaker says "X, what do you think?" then THIS speaker responds
- "introduced_as": Host says "Welcome X" or "Joining us is X" before this speaker talks
- "sign_off": Speaker says "For X and Y, I'm Z" (speaker is Z, NOT X or Y)
- "third_person_ref": Speaker mentions name in third person ("X thinks...", "Thanks X") - NOT valid for self-ID
- "none": No name evidence found

SPEAKER SOURCE - WHO said the identifying phrase:
- "this_speaker": The speaker being identified said it themselves
- "previous_speaker": The turn_before speaker said it
- "next_speaker": The turn_after speaker said it
- "host": The known host introduced/addressed them
- "unknown": Cannot determine who said it

CRITICAL: For "self_id", speaker_source MUST be "this_speaker".
If evidence comes from "next_speaker" or "previous_speaker", it is NOT self-identification of THIS speaker!
""".strip()

JSON_CLUSTER_IDENTIFICATION = """
Think step by step, then return JSON:

1. First, write your analysis: Is there self-ID or being addressed by name?
2. Then return the JSON based on your analysis.

Format:
ANALYSIS: [your reasoning here]

JSON (fill evidence fields FIRST, then conclusions):
{
  "evidence": {
    "quote": "Exact quote containing the name evidence (or empty string if none)",
    "speaker_source": "this_speaker" | "other_speaker" | "unknown",
    "type": "self_id" | "addressed_as" | "introduced_as" | "sign_off" | "third_person_ref" | "none"
  },
  "speaker_name": "Name if found, or 'unknown'",
  "confidence": "certain" | "very_likely" | "unlikely"
}

EVIDENCE TYPES:
- "self_id": Speaker says "I'm X", "My name is X"
- "addressed_as": Another speaker says "X, what do you think?" then THIS speaker responds
- "introduced_as": Host introduces speaker before they talk
- "sign_off": "For X and Y, I'm Z" (speaker is Z, NOT X or Y)
- "third_person_ref": Speaker mentions name referring to someone else - NOT valid for self-ID
- "none": No name evidence found

SPEAKER SOURCE: Who said the identifying phrase?
- "this_speaker": The speaker we're identifying said it
- "other_speaker": A different speaker (host, previous/next speaker) said it
- "unknown": Cannot determine
""".strip()

JSON_GUEST_IDENTIFICATION = """
Return ONLY valid JSON:
{
  "evidence": {
    "quote": "Exact quote containing the name evidence (or empty string if none)",
    "type": "self_id" | "addressed_as" | "introduced_as" | "none"
  },
  "speaker_name": "Name if identified, or 'unknown'",
  "role": "guest" | "co_host" | "unknown",
  "confidence": "certain" | "very_likely" | "unlikely"
}

EVIDENCE TYPES:
- "self_id": The unknown speaker says "I'm X", "My name is X"
- "addressed_as": Another speaker says "X, tell us about..." then the unknown speaker responds
- "introduced_as": Another speaker says "Welcome X" before the unknown speaker talks
- "none": No name evidence found in transcript
""".strip()

JSON_MATCH_VERIFICATION = """
Return ONLY valid JSON:
{
  "evidence": {
    "quote": "Exact quote containing the name evidence (or empty string if none)",
    "type": "self_id" | "addressed_as" | "introduced_as" | "context_match" | "none"
  },
  "identified_name": "Name from transcript if different from candidate",
  "confidence": "certain" | "very_likely" | "probably" | "unlikely",
  "is_match": true/false
}

EVIDENCE TYPES:
- "self_id": The unknown speaker says "I'm X", "My name is X"
- "addressed_as": Another speaker addresses them by name then the unknown speaker responds
- "introduced_as": Another speaker introduces them before they talk
- "context_match": Role/expertise matches candidate without explicit name (lower confidence)
- "none": No name evidence found
""".strip()

JSON_TEXT_EVIDENCE = """
Return ONLY valid JSON (think through reasoning FIRST, then conclude):
{
  "reasoning": "Explanation of your analysis and why this is/isn't valid evidence",
  "evidence_found": true | false,
  "evidence_type": "self_intro" | "addressed" | "introduced" | "none",
  "identified_name": "Canonical name from POSSIBLE_SPEAKERS (if match) or exact transcript name" or null
}

EVIDENCE TYPES:
- "self_intro": The UNKNOWN SPEAKER says "I'm X", "My name is X", "This is X", or "Welcome to [show], I'm X"
- "addressed": Previous/next speaker says "[Name], ..." THEN the UNKNOWN SPEAKER responds
- "introduced": Previous speaker says "Welcome [Name]" or "Joining us is [Name]" BEFORE UNKNOWN SPEAKER talks
- "none": No valid name evidence found

NOTE: If the UNKNOWN SPEAKER says "I'm [Name]", that IS self_intro evidence - even if that name is not in POSSIBLE_SPEAKERS.

CRITICAL RULES:
- If UNKNOWN SPEAKER says "Thanks Bruce" or "I agree with John", they are NOT Bruce/John. They are ADDRESSING someone else. This is NOT valid evidence.
- Do NOT infer identity from context without an explicit statement. You need a direct quote that proves identity.
- You need UNEQUIVOCAL PROOF. If there is any ambiguity or doubt, return evidence_found: false.

FOR identified_name:
- Return the name exactly as identified from the transcript evidence
- If a KNOWN SPEAKER name matches phonetically, use that spelling (e.g., "Joe" â†’ "Joanie")
- Prefer full names over nicknames

Only return evidence_found: true if you find specific, unambiguous transcript evidence that proves identity.
""".strip()


# =============================================================================
# SYSTEM PROMPTS
# =============================================================================

SYSTEM_SPEAKER_IDENTIFICATION = "You are a precise speaker identification assistant. Always return valid JSON."
